# Информация об экзамене

Экзамен по курсу состоится 18 июня, начало экзамена - в 9:30, продолжительность - 2:30.
Экзамен будет в дистанционной форме как контест в тестирующей системе с самостоятельной записью экрана.

Примеры задач экзамена.

## Задача 1

В аргументах командной строки задаются `val1` и `val2`: два 32-битных знаковых целых числа, записанных в девятеричной системе счисления.

На стандартный поток вывода напечатайте два булевских значения (0 или 1), каждое на отдельной строке:

* первое булевское значение равно 1, если сложение (`val1 + val2`) по правилам Си приводит к undefined behavior, и 0 в противном случае
* второе булевское значение равно 1, если деление (`val1 / val2`) по правилам Си приводит к undefined behavior, и 0 в противном случае

Например, если программа называется `solution`, при ее запуске с аргументами:

```
./solution 1000000000 1000000001
```

должно быть выведено

```
0
0
```

## Задача 2

Напишите функцию `float_round` с прототипом:

```
float float_round(float value, int prec);
```

Если `value` — нормализованное значение, функция должна округлить его по арифметическим правилам для получения `prec` битов мантиссы.
То есть, у значения-результата старшие `prec` битов (из 23 битов мантиссы) должны содержать округленный результат,
а младшие (23 - `prec`) битов должны быть равны 0.

Специальные, нулевые и денормализованные значения не должны изменяться.

Параметр `prec` принимает значения от 1 до 23 включительно. Гарантируется, что в результате округления порядок числа не изменяется.

Например:

```
float_round(1.3892822265625, 3) == 1.375
```

Функции стандартной библиотеки, работающие с вещественными числами, использовать запрещено.

## Задача 3

Напишите фрагмент программы на ассемблере x86 (32 бита), который выполняет операции над целыми числами.
В результате выполнения фрагмента флаги процессора должны быть равны: CF = 0, OF = 1, ZF = 0, SF = 1.

Инструкции прямой манипуляции флагами (например, SETcc, POPF) запрещены.
Можете использовать регистры в соответствии со стандартным соглашением о вызовах.
Фрагмент не должен быть подпрограммой, не используйте RET.

Пример фрагмента на ассемблере:

```
        nop
```

## Задача 4

Напишите программу, вычисляющую размер и выравнивание структуры.

На стандартном потоке ввода задается последовательность размеров полей структуры.
Каждый размер является степенью двойки. Требуемое выравнивание поля равно его размеру.

На стандартный поток вывода напечатайте два числа: размер всей структуры и выравнивание для размещения структуры в памяти.
Пустая структура имеет размер 1 и выравнивание 1.

Гарантируется, что размер структуры не превышает `UINT32_MAX`.

Examples
Input

```
1 4
```

Output

```
8 4
```

## Задача 5

На стандартном потоке ввода задается последовательность 32-битных виртуальных адресов, записанных в шестнадцатеричном виде.
В процессоре реализована двухуровневая страничная виртуальная память совпадающая параметрами с реализацией в процессоре x86.

Предположим, что основная кеш-память у процессора отключена и работает только кеш TLB.
TLB изначально пуст и имеет неограниченный размер.
В TLB-кеш помещаются как записи таблицы страниц первого уровня, так и таблицы страниц второго уровня.
Одна ячейка TLB кеша хранит одну запись таблицы страниц.

На стандартный поток вывода напечатайте количество обращений к памяти, которое потребуется для выполнения всех операций обращения к памяти по указанным адресам.

Examples
Input

```
73627a2
7362eee
```

Output

```
4
```

## Задача 6

В аргументе командной строки передается путь к каталогу.
В данном каталоге подсчитайте и выведите на стандартный поток вывода количество файлов,
которые являются исполняемыми файлами формата ELF и могут быть запущены на исполнение с помощью системного вызова семейства `exec`.
Подкаталоги рекурсивно не обрабатывать.
ELF-файлы идентифицировать по первым четырем байтам содержимого файла (см. описание).
Если четыре байта совпадают, предполагайте, что файл является корректным файлом формата ELF, который может быть обработан системным вызовом семейства exec.
Символические ссылки разыменовывать до файлов, на которые они указывают.

## Задача 7

Запустить процессы в конфигурации, эквивалентной следующей команде shell:

```
(CMD1 ; CMD2) | (CMD3 ; CMD4)
```

Аргументы CMD1 CMD2 CMD3 CMD4 задаются в командной строке в указанном порядке.
Для запуска процессов используйте fork и execlp.
Использовать system или /bin/sh или аналогичные высокоуровневые средства запрещено.
Запись `A ; B` означает последовательное выполнение команд A и B.

## Задача 8

В аргументе командной строки задается имя регулярного файла, содержащего 32-битные знаковые целые значения в бинарном представлении хост-системы.
На стандартный поток вывода выведите число, которое встречается в этом файле максимальное число раз, и количество его повторений.
Если таких чисел несколько, выведите минимальное из них и количество его повторений.
Если такое число не существует, выведите два числа 0 и 0. Количество значений в файле не превосходит 8388608.

## Задача 9

В аргументах командной строки передается команда для выполнения.
Программа должна запустить эту команду с помощью fork и execlp и через 100мс вывести на стандартный поток состояние процесса запущенной команды (S, R, D, Z, ...)
в первой строке и размер RSS процесса в килобайтах. После вывода гарантировано завершите дочерний процесс.

Например, для запуска с аргументом `cat` вывод может быть таким:

```
S
780
```

## Задача 10

Реализуйте пинг-понг между двумя нитями.

Программе в аргументах командной строки задается максимальное значение (`maxval`).

Программа должна создать 2 нити и запустить между ними пересылку числа.
Каждая нить получает число, печатает свой порядковый номер (от 0) и значение числа, как показано в примере,
увеличивает его на 1 и пересылает число соседней нити.
Если значение числа достигло `maxval`, нить после печати завершает свою работу, соседняя нить так же должна завершиться.
Основная нить должна дождаться завершения обоих нитей.
Игра начинается с первой из созданных нитей со значения 0.

Для создания нитей и синхронизации разрешается пользоваться только средствами стандартной библиотеки С++.

Пример вывода для аргумента 1 показан ниже.

Examples
Input

Output

```
0 0
1 1
```
